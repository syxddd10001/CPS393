Q1: No.
Q2: str1 with XX appended (or maybe error)
Q3: one or both 'X' and the final '\0' could end up past allocated
    storage

HMWK:
1. Write a function with prototype: void swap_string1(char *A, char *B);
The function swaps the strings in A and B. It does this by looping
through the string(s) and swapping individual characters. If your
function needs to know the length of a string, it can use strlen
from string.h, or it can just look for the '\0' at the string end.
Write a main program to test swap_string1. Your main must allocate
all the storage required for the strings.


#include <stdio.h>
#define MAX 100
void swap_string1(char *A, char *B);

int main (void) {
  char S1[MAX]="ABC";   //tried these with different
  char S2[MAX]="defgh"; //strings for S1 and S2
  printf("S1: %s\nS2: %s\n",S1,S2);
  swap_string1(S1,S2);
  printf("S1: %s\nS2: %s\n",S1,S2);
  swap_string1(S1,S2);
  printf("S1: %s\nS2: %s\n",S1,S2);

  return 0;
}
void swap_string1(char *A, char *B) {
  char temp, *tempP;
  while ( *A != '\0' && *B != '\0' ) {
    temp = *A;
    *A = *B;
    *B = temp;
    A++ ; B++ ;
  }
  //strings unequal lengths, so finish-off the tail end
  if ( *A == '\0' && *B !='\0' ) {
     tempP=B;
     while ( *B ) *A++=*B++;
     *A='\0' ; *tempP='\0' ;
  }
  else if ( *A != '\0' && *B =='\0' ) {
     tempP=A;
     while ( *A ) *B++=*A++;
     *B='\0' ; *tempP='\0' ;
  }
}


Q4: it is strlen
Q5: no corruption. A is a COPY of str, so main's value for str is
    unchanged.

HMWK:
Modify encode.c from bottom of c1.txt so that it
reverses a string IN PLACE, using a swap function
repeatedly.  i.e.,  "abcdef" becomes "fedcba"
Print string before, and after, the encoding

#include <stdio.h>
#include <string.h>
void swap( char *x, char *y );

int main(void) {
  char str[80];
  int i,j;
  printf("Enter string to be encoded: ");
  gets(str);
  printf("Original string: %s\n", str);
  /*encode it*/
  i=0;
  j=strlen(str)-1;
  while (i <=j) {
    if (i<j) swap(&str[i],&str[j]);
    /* else i==j so nothing to do*/
    i++; j--;
  }
  printf("Encoded  string: %s\n", str);
  return 0;
}
void swap( char *x, char *y ){
   char temp=*x;
   *x=*y;
   *y=temp;
}




HMWK:
sum.c should check CLAs contain only digits.
Fix it.

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

int allDigits(char *S) {
     while ( *S ) {
      if ( ! isdigit(*S)) return 0;
      S++;
   }
   return 1;
}

int main (int argc, char *argv[]) {
    int i,     /*for loop index*/
    sum=0;     /*the sum of the arguments*/

    for (i=1; i<argc; i++) {
      if ( allDigits(argv[i]))
           sum = sum + atoi(argv[i]);
      else {
         fprintf(stderr,"Usage: %s [<int> <int> ... <int>]\n",argv[0]);
         exit(1);
      }
    }
    printf("Sum of the %d integers is %d\n", argc-1, sum);
    exit(0);
}

Q6: Would have lost the start of the string. Also, str is a string
    constant stored in string table, so can't change it.

HMWK:
Modify cio2.c to turn it into a simple version of unix
utility "cat". If no cmd-line input, prints stdin on
stdout. If cmd-line inputs (files), print each on stdout

/*Source: cio2.c
  Purpose: display contents of myfile on stdout
*/
#include <stdio.h>
#include <stdlib.h>
#define GOOD 0
#define BAD 1
int main(int argc, char *argv[]) {
  FILE *fp;
  int ch,i;

  for (i=1;i<argc;i++) {

     if ((fp=fopen(argv[i], "r"))==NULL) {
        fprintf(stderr,"fopen: Cannot open file %s\n",argv[i]);
        exit(BAD);
     }
     while (( ch = fgetc(fp)) != EOF)
           fputc(ch,stdout);
     fclose(fp);
  }
  if (argc == 1 ) { /*no command line args */
     while (( ch = fgetc(stdin)) != EOF)
           fputc(ch,stdout);
     
  }

  exit(GOOD);
}


HMWK:
1. Rewrite copy.c using fgets, fputs, feof and ferror
assuming max line length in file is 128 chars.


/*Source:  copy.c
  Purpose: copy file f1 to file f2
  Usage:   copy f1 f2
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define GOOD 0
#define BAD 1

int main (int argc, char *argv[]) {
 FILE *f1, *f2;
 int ch;
 char str[128];

 if (argc != 3) {
    fprintf(stderr, "Usage: %s <source> <destination>\n",argv[0]);
    exit(BAD);
 }
 if ((f1=fopen(argv[1],"r"))==NULL) {
    fprintf(stderr, "Cannot open %s\n",argv[1]);
    exit(BAD);
 }
 if ((f2=fopen(argv[2],"w"))==NULL) {
    fprintf(stderr, "Cannot open %s\n",argv[2]);
    exit(BAD);
 }
 while (!feof(f1)) {
   fgets(str,127,f1);
   if (ferror(f1)) { fprintf(stderr,"error reading file %s\n", argv[1]); exit(BAD); }
   if(!feof(f1)) fputs(str,f2);
   if(ferror(f2)) { fprintf(stderr,"error reading file %s\n", argv[2]); exit(BAD);}
 }
   
 exit(GOOD);
}

HMWK:
1. Write a program named prt.c that reads text from
stdin until EOF and prints the number of lines and/or
characters that were read in. The program takes
one command line argument, which is l or c or b.
If the argument is l, the program prints the
number of lines, if c, the number of characters,
and if b, it prints the number of both lines and chars.

#include <stdio.h>
#include <stdlib.h>

int main (int argc, char *argv[]) {
  int lines=0, chars=0;
  char c;

  if ( argc != 2 ) {
     fprintf(stderr,"usage: %s [clb]\n",argv[0]);
     exit(1);
  }

  while ( (c=fgetc(stdin)) != EOF ) {
   if ( c == '\n' ) lines++;
   chars++;  
  }
  if ( argv[1][0] == 'c' || argv[1][0] == 'b' ) printf("%d chars\n",chars);
  if ( argv[1][0] == 'l' || argv[1][0] == 'b' ) printf("%d lines\n",lines);
  exit(0);
}

2.  Re-write program prt.c above
except this time, the program takes 2 arguments,
the second argument being the name of a file from
which to read the text.  Perform *full* error checking.

#include <stdio.h>
#include <stdlib.h>
#define BAD 1
#define GOOD 0

int main (int argc, char *argv[]) {
  int lines=0, chars=0;
  char c;
  FILE *fp;

  if ( argc != 3 ) {
     fprintf(stderr,"usage: %s [clb] file\n",argv[0]);
     exit(BAD);
  }

  if ((fp=fopen(argv[2], "r"))==NULL) {
     fprintf(stderr,"fopen: Cannot open file %s\n",argv[2]);
     exit(BAD);
  }


  while ( (c=fgetc(fp)) != EOF ) {
   if ( c == '\n' ) lines++;
   chars++;  
  }
  if ( argv[1][0] == 'c' || argv[1][0] == 'b' ) printf("%d chars\n",chars);
  if ( argv[1][0] == 'l' || argv[1][0] == 'b' ) printf("%d lines\n",lines);
  exit(GOOD);
}


3. Re-write the above prt.c so that any number of
files are processed (number of chars/lines printed
for EACH, in order processed.)




#include <stdio.h>
#include <stdlib.h>
#define BAD 1
#define GOOD 0

int main (int argc, char *argv[]) {
  int lines, chars, i;
  char c;
  FILE *fp;

  if ( argc < 3 ) {
     fprintf(stderr,"usage: %s [clb] files  ]\n",argv[0]);
     exit(BAD);
  }
  for (i=2; i<argc; i++ ) {
     lines=0; chars=0;
     if ((fp=fopen(argv[i], "r"))==NULL) {
        fprintf(stderr,"fopen: Cannot open file %s\n",argv[i]);
        exit(BAD);
     }
   
   
     while ( (c=fgetc(fp)) != EOF ) {
      if ( c == '\n' ) lines++;
      chars++;  
     }
     if ( argv[1][0] == 'c' || argv[1][0] == 'b' ) printf("%d chars\n",chars);
     if ( argv[1][0] == 'l' || argv[1][0] == 'b' ) printf("%d lines\n",lines);
  }
  exit(GOOD);
}


4.  Use fscanf and fprintf to read a file with 2 columns of
integers, such as:
 2  4
 7  9
10  6
and write the sum of each line to another file, e.g,
6
16
16
The file names are given on the command line


#include <stdio.h>
#include <stdlib.h>
#define BAD 1
#define GOOD 0

int main (int argc, char *argv[]) {
  int i1, i2;
  char c;
  FILE *fp1, *fp2;

  if ( argc != 3 ) {
     fprintf(stderr,"usage: %s [clb] file\n",argv[0]);
     exit(BAD);
  }

  if ((fp1=fopen(argv[1], "r"))==NULL) {
     fprintf(stderr,"fopen: Cannot open file %s\n",argv[1]);
     exit(BAD);
  }

  if ((fp2=fopen(argv[2], "w"))==NULL) {
     fprintf(stderr,"fopen: Cannot open file %s\n",argv[2]);
     exit(BAD);
  }

  while ( fscanf(fp1,"%d %d\n",&i1,&i2) != EOF ) {
     fprintf (fp2,"%d\n",i1+i2);
  }
  exit(GOOD);
}

HMWK:
Write a program that reads an input file such as:
1 5
2 -4
-3 9
8 2
Each line of the file contains a "complex number".
Assume at most MAX=100 numbers are given.
The program must create a structure for a complex
number, and then store all the complex numbers
in an array.  (You must have an array of structures.)
Then your program should loop through
the array from end to front, and print out the
complex numbers in it. E.g., your output should
look like
 8 +  2i
-3 +  9i
 2 + -4i
 1 +  5i
on stdout.


#include <stdio.h>
#include <stdlib.h>

typedef struct complex {
   int real;
   int imag;
   } complex_t ;

int main (int argc, char *argv[]) {

  FILE *fp;
  complex_t clist[100];
  int i, num_complex=0;

if (argc != 2) {
   fprintf(stderr, "%s: expect file as argument\n",argv[0]);
   exit (1);
}
if ( ((fp = fopen(argv[1],"r")) == NULL) ) {
   fprintf(stderr,"%s: error opening file %s\n",argv[0],argv[1]);
   exit(2);
}

  i=0;
  while ( fscanf(fp,"%d %d\n",&clist[i].real, &clist[i].imag) != EOF ) {
    i++;
  } 
  num_complex=i;
  for (i=num_complex-1;i>=0;i--)  {
    printf("%5d + %5di \n",clist[i].real, clist[i].imag);
  }
return 0;
}
