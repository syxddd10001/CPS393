Question:
Optional: Write a version of Add that does not mutate (change) the
list; instead,
it should return a new list.
The function prototype could be NodeType *Add(NodeType *L, char
c);

/*Source addNM.h
  header file for addNM.c
*/

typedef struct node NodeType;

struct node {
	char ch;
	NodeType *next;
   };

NodeType *Add(NodeType *L, char c);

/*Source addNM.c
  function to add to front of list
*/
#include <stdio.h>
#include <stdlib.h>
#include "addNM.h"

/*Note: do not need to pass address of L because it is
  not being changed. The "new" list returned, conists of
  the original list with a new node on the front.
*/
NodeType *Add(NodeType *L, char c) {

NodeType *new;
new=(NodeType *) malloc(sizeof(NodeType));
new->ch=c;
new->next=L;
return new;
}

/*Source addNMmain.c
  like addmain.c, except the Add function RETURNS the "new" list
  Note that the nodes of the list passed to AddNM will become
  part of the returned list. i.e., nodes are NOT duplicated.
*/
#include <stdio.h>
#include "addNM.h"

int main(void) {

 NodeType *Pair,   /*a pair, like in scheme*/
         *List,   /*a list, like in scheme, except all char*/
         *ptr;    /*a temp var to move along a list, pair by pair*/
 char     ch;      /*char to add to front of list*/

 List=NULL;

/*add a b c d e, each to front of list*/
 for (ch='a'; ch<'f';ch++) 
   List=Add(List,ch);       

 printf("List is: ");  /*print list*/
 for (ptr=List; ptr!=NULL; ) {
   printf(" %c ", ptr->ch);
   ptr=ptr->next;
 }
 printf("\n");

return 0;
}

Question:
Write function InsertO which inserts a given item into a list, keeping
the list in order.
Write function SrchO which searches an ordered list for the given item.
Note that if the item is not in the list, search can terminate as soon
as it finds an item larger than the searched-for item.

Answer:

/*Source insertO.h
  header file for insertO.c
*/

typedef struct node NodeType;

struct node {
	char ch;
	NodeType *next;
   };

void InsertO(NodeType **L, char c);


/*Source insertO.c
  function to add a char to the front of a list 
*/
#include <stdio.h>
#include <stdlib.h>
#include "insertO.h"

/*Note: need to pass address of L so that it is call by value
  if just passed *L, any changes to L inside function would
  be lost upon function return. e.g., calling InsertO(List,ch)
  would not cause List to be changed after insertO return
*/
void InsertO(NodeType **L, char c) {

  NodeType *new;
  NodeType *prev,*p;
  new=(NodeType *) malloc(sizeof(NodeType));
  new->ch=c;

  //if L is empty add new
  if ((*L)==NULL) {
     new->next=*L;
     *L=new;
     return;
  }

  //if new goes at start of list, insert it there
  if (c<(*L)->ch) {
     new->next=*L;
     *L=new;
     return;
  }

  //if new goes somewhere inside list, find spot and insert it
  //between nodes prev and p
  prev=(*L);
  for (p=prev->next; p != NULL; p = p->next) {
     if (p->ch < c)                //move along list
        prev=prev->next;
     else {                        //insert new between prev and p
       prev->next = new;
       new->next = p;
       return;
     }
  }
  //item must go at end of list (after prev)
  prev->next=new;
  new->next=NULL;
  return;
  
}


/*Source insertOmain.c
  program to use function InsertO (in file insertO.c) to add to 
  ordered list
*/
#include <stdio.h>
#include "insertO.h"

int main(void) {

 NodeType *Pair,   /*a pair, like in scheme*/
         *List,   /*a list, like in scheme, except all char*/
         *ptr;    /*a temp var to move along a list, pair by pair*/
 char     ch;      /*char to add to front of list*/

 List=NULL;

/*add each to ordered list*/
   InsertO(&List,'b');  
   InsertO(&List,'c');  
   InsertO(&List,'a');  
   InsertO(&List,'d');  

 printf("List is: ");  /*print list*/
 for (ptr=List; ptr!=NULL; ) {
   printf(" %c ", ptr->ch);
   ptr=ptr->next;
 }
 printf("\n");

return 0;
}
