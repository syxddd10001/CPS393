

HMWK: How would you list all file/dir names that:
1. contained the letter "e";
2. had a total of 7 characters and no extension;
2a. are 7 characters long
3. had 3 character extensions;
3a. had 3 character alpha-numeric  extensions;
4. contained the word "tst" *somewhere* in the name;
5. started with the letter "A" and contained a dash (-);
6. are at least 2 characters long and don't have the following letters
   anywhere in the first 2 characters: a,b,c,f,h,x,y,z
7. end in .ex with an optional c at the end
8. are not java or text files (don't end in .jav or .txt)
9. end in a : followed by a digit from 2-8 followed zero or more
   digits.

ANSW:
1. ls *e*
2.  ls [!\.][!\.][!\.][!\.][!\.][!\.][!\.] 
2.  ls [!.][!.][!.][!.][!.][!.][!.] 
2a. ls ???????
3. ls *.[!\.][!\.][!\.]  #or with no backslashes, as above
3a. ls *.[A-z0-9][A-z0-9][A-z0-9]
4. ls *tst*
5. ls A*-*
6. ls [!abcfhxyz][!abcfhxyz]*
7/8/9. shopt -s extglob  #this is for number 7, 8, 9.
7. ls *.ex?(c)
8. ls !(@(*.jav|*.txt))
9. ls *:[2-8]*([0-9])

HMWK: In the shell, is grep '[A-Za-z][A-Za-z]*' fname  the same as
grep -i '[A-Z]*' fname ? Why or why not?
Why do you think "\<" and \>" are used instead of simply "<" and ">" for
beginning/end of line?
For questions 1-6 below, write a different shell program.
1. list all lines in file fname containing the string "dog";
2. list all lines in fname containing the word "dog";
3. list all lines in fname containing the string "dog" at the beginning of
   a line;
4. list all lines in fname containing the word "dog" at the beginning of a line.
5. list all lines in fname containing exactly 6 "a"s in a row.
6. list all lines in fname containing one or more words that start with 93 and
   end in a sequence of any number of W (not 0)
7. Give 2 different grep commands that will list lines of fname that
   end in a lower-case vowel.
8. Use the man page to find the option of grep that shows the matched string
   in a different color. Try it.
9. How would you change your program for #1 above so that instead of doing grep
   directly from the file, it cat`s the file, then pipes that to grep which
   greps from stdin?
10. Print the first 3 lines of AlanTuringBio80 that contain the string 'machine'
   (in any case). Use grep, pipe(s), head


ANSW:
No. The second one also finds blank lines. The first one says show lines containing
     at least one alpha character. The second says show lines that DON'T contain
     a string of upper-case letters (this will include the null string, thus, the 
     blank lines.)
If we just used < and >, the shell would think these were input and output redirection.
   Using \ before < and > protects them from shell interpretation, and sends literal < and >
   to the grep command.

For 1-8--the programs go into a file with u+x perms

For 1.
#!/bin/bash
grep "dog" fname

For 2.
#!/bin/bash
grep "\<dog\>" fname

For 3.
#!/bin/bash
grep "^dog" fname

For 4.
#!/bin/bash
grep "^\<dog\>" fname

For 5.
#!/bin/bash
grep "aaaaaaaa" fname

For 6.
#!/bin/bash
grep "\<93[^ ]WW*\>" fname
#grep '\<93[^ ]*W\{1,\}\>' fname

For 7.
grep "[aeiou]$" fname
egrep 'a$|e$|i$|o$|u$' fname

For 8:
man grep   #use / to search for color and find option --color
grep --color dog /usr/courses/cps393/dwoit/courseNotes/u1.txt
   
For 9.
#!/bin/bash
#grep "dog" fname
cat fname | grep "dog" 

For 10.
grep -i machine AlanTuringBio80 | head -3

HMWK:
1. Use the "find" command to list all entries in directory /bin
that start with the letter "m".
2. What would happen if we did not put
a name such as "*.jav" in quotes in the find command? Make sure you have
some .jav files in your directory and try it out.
3a. Look at the man pages for "find" to determine what the option
"-mtime" does in the find command. Then...
Figure out a sequence of commands (involving a find, temp file and a grep)
to display those FILES in the current directory whose contents were
changed within the last 24 hours and whose names contain the string "tst".
3b. How would you do 3a using a pipe and no temporary files?
4a. Make a shell program to do question 3 above. Call your program tstRecent
Your program should delete any temporary files it creates.
Test it to make sure your program works.
4b. Rewrite your program from 4a to use pipes instead of temp files.
5. Use the man pages to find out how find's -maxdepth option works. Use
-maxdepth 1 to list all entries in the given directory only (not the whole filetree)


ANSW:
1.
find /bin -name "m*"
2.
touch a.jav bb.jav ccc.jav
find . -name *.jav
#get error message saying used find command incorectly. This is because shell
#first expands the *.jav before running the command. The command that is really
#run is: find . -name a.jav bb.jav ccc.jav
#So find complains, because it expects just one pattern to match after -name, but
#you gave it 3 files instead of 1 pattern.
3a.
man find   #use /mtime to search for mtime, and then keep typing / to repeat
           #the search. Once you find its description, read about it. 
           #Eventually, you will see description for  -mtime n 
find . -mtime 0 -type f >tempfile1       #files modified in last 24 hours
grep -v '.*/.*/' tempfile1 >tempfile2    #this omits lines that contain more than one / 
                                         #so only files in CURRENT dir are shown (none 
                                         #are shown from subdirectories)
grep tst tempfile2                       #show only those with tst in name
3b. 
find . -mtime 0 -type f | grep -v '.*/.*/' | grep tst 

4a.
> cat tstRecent
#!/bin/bash
find . -mtime 1 -type f >tempfile1
grep -v '.*/.*/' tempfile1 >tempfile2
grep tst tempfile2
rm tempfile[12]
>
>./tstRecent  #can use ls -l to check when files were modified

4b.
> cat tstRecentNoTemps
#!/bin/bash
find . -mtime 1 -type f | grep -v '.*/.*/' | grep tst 
>
>./tstRecentNoTemps  #can use ls -l to check when files were modified

5.
find . -maxdepth 1
Try this:
cd /usr/courses/cps393/dwoit/courseNotes
Notice the different outputs you get with the 2 commands:
find . -maxdepth 1
find . 
Note that in question 4 above we could have omitted a grep if we had added -maxdepth 1 
to the find command.

---------------------------------------------------------------------------------------------------
HMWK:
The following program displays, on stdout, line 6 of file
/usr/courses/cps393/dwoit/courseNotes/vimSummary.txt:

#!/bin/bash
#program to print line 6 of vimSummary.txt
head -6 /usr/courses/cps393/dwoit/courseNotes/vimSummary.txt | tail -1 

Copy the code into a file called showline and modify it as follows:
      Make it able to show ANY line of ANY file, with
      line and file given as a command line argument, as in:
      ./showline 5  myfile  #to show line 5  of file myfile
      ./showline 54 dog     #to show line 54 of file dog

ANSW:
#!/bin/bash
#     ./showline n filename #to show line n of file filename
head -$1 $2 | tail -1 


HMWK:
(1) Create a file called stdnt-file with last-names in column 1,
first-names in column 2, id numbers in column 3, userids in column 4.
What combination of commands (and possibly temp files) can you use
to create a file, stdnt-ids, that contains only the id numbers and
userids from stdnt-file?
(2) How can you combine commands (and possibly temp files) to create
another file, stdnt1, that contains only the first and last students
in stdnt-file?
(3) How can you combine commands to find out exactly how long userid
dwoit (or whoever you want) has been idle (has not been typing anything)?
You will find the "w" command useful. It tells you who is logged in,
and what they`re doing. For an explanation do:  man w
Note that "dwoit" (or whoever) will likely have multiple entries (one
for each "terminal" connection), so your output may have multiple lines.


ANSW:
1.
> cat stdnt-file  #assume columns are separated by spaces
wong    larry    123456789   l22wong
arisa   torrie   115987987   tarisa
islam   frank    129876444   f3islam
benes   maria    107645363   mbenes
> cut -c18- <stdnt-file >stdnt-ids
#Note: if you separated the columns using tabs, then:
> cut -f3-4 <stdnt-file >stdnt-ids

2.
> head -1  >stdnt1
> tail -1  >>stdnt1

3.
When I did the w command I got output such as:
----------------------------------------------------------------------------
 14:43:13 up 129 days,  1:14, 11 users,  load average: 0.01, 0.02, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    10.0.0.48        09May12 13days  0.04s  0.04s -bash
l85patel pts/1    dpx10465ff77c19- 13:00    1:46   0.86s  0.86s vi unix1.txt
irubiale pts/2    tents.scs.ryerso 09May12  1:25m  0.90s  0.90s -bash
dwoit    pts/3    bas3-toronto46-1 13May12  7:55   4.80s  0.02s /usr/bin/vim unix3.txt
eharley  pts/4    comet.scs.ryerso Wed18    4:30  25.86s 25.86s pine
dwoit    pts/5    bas3-toronto46-1 13:05    4.00s  0.06s  0.00s /usr/bin/vim dog
etc
----------------------------------------------------------------------------
So I saw to cut out the column in positions 44-50

> cat howLongIdle dwoit
#!/bin/bash
w >tmp1
grep "$1" tmp1 >tmp2
cut -c44-50 <tmp2 


HMWK: Use various commands and pipes to do the following (do not
use any temp files):
1. List, in long form, all those files in your home directory that have
read, write and execute perms for you, and whose name contains the
string "txt".
2. Do the above question again, but list in short form
(just the file names.)
3. List any lines in the first 10 lines of a file, myf, that contain the
word "dog". (you should create different versions of myf to test your
commands.)
4. Find all lines of file, myf, that contain all the words "cat", "dog"
and "mouse", in any order, and start with the letter "A".
5. List all the files in your home dir that contain the string "so"
somewhere within them. Next, just list the *number* of files in your
home dir that contain the string "so" (you should use, among other
commands, the command "wc -l", word-count (lines option), which you
should look up in the man pages.)
6. Use only ls, grep, cut, pipes to answer this question. What sequence
of pipes and commands could you issue from your home dir
to list, in alphabetical order, the absolute path names of all the
directories in your file system (if you NEED to, use the sort command.)
7. List the names of any subdirectories of your home directory that have
rwx permissions for user and group, and no permissions for
others--note: list just the directory names in short form (the names only.)
8. List just names of all files/directories that have no extension;
9. List just names of all files/directories that contain no vowels at
all.
10. Write a shell program called nw that takes either zero or one
 command line arguments.

 nw with no arguments should print out the 10 newest (most recently
 modified) files/dirs in the current directory.
 nw -n  (nw with one argument, -n) prints out the n newest
 files/dirs in the current directory.
 e.g., nw -3  prints out the 3 most recently modified files/dirs
 If the argument is incorrect, then your program is allowed to
 do unpredictable things!
11. List names in reverse alphabetical order, of directories that have "r"
permissions for "other". (the "reverse" option of the sort command may
be useful.)
12. List in alphabetical order all files in the current directory that have
been edited exactly 3 days ago. Do not list the same file more than once.
(the uniq command will eliminate duplicate lines).


ANSW:
1.
ls -l /home/USERID/*txt* | grep '^-rwx'
2.
ls -l /home/dwoit *txt* | grep '^-rw' | cut -c43-   #note your columns might differ (might not be 43)
3.
head myf | grep '\<dog\>'
4.
grep '^A' myf | grep cat | grep dog | grep mouse
5.
grep "so" /home/USERID/*
grep "so" /home/USERID/* | wc -l
6.
This works for me because I have no directories with ":" in the name, and my userid is 5 characters
long. (So I cut the /home/dwoit off with cut -c13-
ls -R /home/USERID/* | grep ":$"  | cut -c13-

7.
ls -l /home/dwoit/* | grep 'drwxrwx---' | cut -c44-   #your 44 might differ

8.
ls | grep -v '\.'

9.
ls | egrep -v 'a|e|i|o|u|A|E|I|O|U'
ls | grep  "^[^aeiouAEIOU][^aeiouAEIOU]*$"

10.
> cat nw
#!/bin/bash
ls -t | head $1


11.
ls -l | grep '^d......r' | cut -c44- | sort -r

12.
ls -l | grep '^-' | grep 'Oct 28'    #assuming Oct 28 was 3 days ago



