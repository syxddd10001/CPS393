HMWK:
1. Give a sed command that changes every occurrance of the string
"xyz" on stdin to "zyx".
2. Give a sed command that changes every occurrance of the string
"xyz" to "zyx" on lines stdin EXCEPT lines 3-5.
3. Give a sed command that makes all alpha characters on stdin lower-case.
4. Give a sed command that deletes all lines of stdin containing
three or more digits in a row.
5. Give a sed command that deletes the third occurrance of string
"xyz" on every line of stdin.
6. Give a sed command that puts double quotes around any string of
two or more repeated A characters. e.g.,
this line: abcAbcAAzzzzAAAAzzABCC
becomes  : abcAbc"AA"zzzz"AAAA"zzABCC

1. sed -e 's/xyz/zyx/g'
2. sed -e '3,5 !s/xyz/zyx/g'
3. sed -e 's/[A-Z]/\L&/g'
4. sed -e '/[0-9][0-9][0-9]/'d
5. sed -e 's/xyz//3' 
6. sed -e 's/\(AAA*\)/"\1"/g'




HMWK:
 1. write a shell program called myenv which takes one argument.
 The argument should be the name of an environment variable,
 such as PATH HOME etc. myenv should print out the value of the
 variable given as the argument. If no argument is given, or the argument
 is invalid, your program could do unpredictable things!
 e.g., myenv PRINTER
 should print a line such as:  PRINTER=kc3500
 e.g., myenv HOME PRINTER
 should print a line such as:  HOME=/home/dwoit



ANSW:
> cat myenv
#!/bin/bash
env | grep "$1"




HMWK: Write a shell program called sg that takes 2 command line arguments.
      The first argument is a textual string; the second a file name.
      If other than 2 args are supplied it prints on stderr:
      sg: Usage: sg str file
      (the sg is printes so that if you change the name of the program,
      the "Usage line" changes automatically.)
      If the second arg is not a readable file, print on stderr:
      sg: file xxx invalid or not readable
      where "xxx" is arg2
      Your program will return 0 if string is contained somewhere in the
      file, and 1 if something wrong with args, and 2 if string not in
      file (but args OK).  (use grep in your program).

ANSW:
> cat sg
#!/bin/bash
if [ $# -ne 2 ] ; then
  echo "$0: Usage: $0 str file" >/dev/stderr
  exit 1
fi
if [ ! -r "$2" ] ; then
  echo "$0: file $2 invalid or not readable" >/dev/stderr
  exit 1
fi
if [ "`grep $1 $2`" ] ; then
  exit 0
else 
  exit 2
fi




HMWK: Re-write shell program ff above so that it does something
      reasonable when the user invokes it without a command argument
      (or with a null argument as in:  ff ""  )


ANSW:
#!/bin/bash
if [ -z "$1" ] ; then
   echo "argument missing" >/dev/stderr
   exit 1
fi
if [ "`grep $1 f1`" ]
then  
   echo string $1 is contained in file f1
else  
   echo string $1 is not contained in file f1
fi    
exit 0



HMWK: Write a shell program that will tell you how long another
user`s session has been idle.
If the user has more than one idle session, just look at the first one.
To see idle time, use the who command with options -H -u.
Idle time is given in minutes. If a user is idle for less than a minute,
a . appears instead of a time.
The program will take a userid as an argument
and will do one of (a), (b), or (c) below:
   (a) print "user userid is not logged in" and exit 1
   (b) print "user userid has been idle at least 1 minute and exit 0
   (c) print "user userid has been idle less than 1 minute and exit 0


ANSW:

#!/bin/bash
#this tells if a user has been on for less than a minute by looking for
#a . for a user`s idle time. As of F23 it would appear in column 42,
#but this could change in subsequent implementations
#!/bin/bash
if [ -z "$1" ] ; then
   echo "Usage: $0 userid" >/dev/stderr
   exit 1
fi
userLine="`who -u -H | grep $1 | head -1`"
if [ -z "$userLine" ] ; then
  echo "user $1 is not logged in"
  exit 1
fi
col42="`who -u -H | grep $1 | head -1 | cut -c42`"
if [ "$col42" = '.' ] ; then
  echo "user $1 has been idle less than 1 minute"
else
  echo "user $1 has been idle at least 1 minute"
fi
exit 0



HMWK:
1.re-write your homework program called nw (from u2) so that if
no argument is passed, all of your entries in the current dir are printed
(instead of only 10 as before)
2. write a shell program called x that makes your most recently created
   file executable.

1.
#!/bin/bash
if [ -z "$1" ] ; then
  ls -t
else
  ls -t | head -$1
fi
exit 0

2.
#!/bin/bash
chmod u+x `ls -t | head -1`


HMWK: 1.write a shell pgm called lst which acts like ls -F, using
      a shell for loop (Note ls -F puts a '/' after dir names and
      a '*' after any files  that are user executable and a '@'
      before any that are symbolic links. Look at 'man bash' or
      'man test' to find the test for symbolic links)
      2. write a shell program called num that prints the number
      of entries in the current directory. USE A LOOP and counter. No pipes.
      3. modify your program nw from previous homework so that if the
      argument is a number larger than the number of entries IN the
      current directory, the following message is printed:
       there are only $num entries in this directory
      The new nw should use your program num from above to assign the
      number of files/dirs to a variable.

ANSW:
1.
#!/bin/bash
for i  ; do
  if [ -d "$i" ]  ; then
     echo "${i}/"
  elif [ -x "$i" ] ; then
     echo "${i}*"
  elif [ -h "$i" ]  ; then
     echo "${i}@"
  else 
     echo "${i}"
  fi
done

2.
> cat num
#!/bin/bash
declare -i count=0
for i in $(ls) ; do
   count=count+1
done
echo $count
> #double-check it. These should give same number:
> ls | wc -l
> ./num

3.
#!/bin/bash
if [ -z "$1" ] ; then
  ls -t
else
  numEntries="$(num)"
  if [ "$numEntries" -lt "$1" ]  ; then
     echo there are only $numEntries entries in this directory
  else
     ls -t | head -$1
  fi     
fi
exit 0



HMWK:
0. If the numbers from 1 to 4321 were written out, how many times would the
   digit '5' appear? Write a shell program to figure this out.


#!/bin/bash
seq 4321 | \
  while read -n1 digit; do  
     echo $digit
  done | grep -c 5

#!/bin/bash
typeset -i n=1
while [ $n -le  4321 ] ; do
  echo $n
  n=n+1
done | \
  while read -n1 digit; do  
     echo $digit
  done | grep -c 5


1. write a shell program called numit which reads lines from stdin
  and outputs the lines with line numbers.
  e.g., if stdin was 
  this is a line
  this is now another line
  and here is line
  
  Then numit would print
  1. this is a line
  2. this is now another line
  3. and here is line
  
  And if file dog contained
  Abcde

  klm
  n
  Then numit <dog  would print
  1. Abcde
  2.
  3. klm
  4. n


#!/bin/bash
typeset -i lineNum=1
while read line ; do
  echo "${lineNum}. $line"
  lineNum=lineNum+1
done

2. write a program like numit above, except that IF a command line
  arg is given, it will check to see if the arg is a file, and if so,
  will output to stdout that file with line numbers as above. If it`s
  not a file, or not readable, it will print an error message.
  Call this program num2

> cat num2
#!/bin/bash
if [ -z "$1" ] ; then
  typeset -i lineNum=1
  while read line ; do
    echo "${lineNum}. $line"
    lineNum=lineNum+1
  done
  exit 0
fi

if [ ! -f "$1" -o ! -r "$1" ] ; then
  echo "$0: $1 is not readable file"
  exit 1
fi
typeset -i lineNum=1
while read line ; do
  echo "${lineNum}. $line"
  lineNum=lineNum+1
done <$1
exit 0

3. modify the program in 2 above so that it will take any number of files
  as command line args, and number them consecutively on stdout. Call this
  program num3
  e.g.,
  if file f1 was:
  abc def
  gh ij
  k
  and file f2 was:
  a b c
  deflsjk
  ds
  fkl
  Then  num3 f1 f2
  would print
  1. abc def
  2. gh ij
  3. k
  4. a b c
  5. deflsjk
  6. ds
  7. fkl


#!/bin/bash
if [ -z "$1" ] ; then
  typeset -i lineNum=1
  while read line ; do
    echo "${lineNum}. $line"
    lineNum=lineNum+1
  done
  exit 0
fi

typeset -i lineNum=1
for aFile ; do
   if [ ! -f "$aFile" -o ! -r "$aFile" ] ; then
     echo "$0: $aFile is not readable file" >/dev/stderr
   else
     while read line ; do
       echo "${lineNum}. $line"
       lineNum=lineNum+1
     done <$aFile
   fi
done
exit 0


4. Write a program called biggest that takes any number of arguments.
For all the arguments that are files, it finds
the file with the most words in it, and prints a line such as:
 File whatever has largest number of words (37)
assuming the file called "whatever" has 37 words, which is more (or the
same) as any other files in the current directory.
If no arguments were valid files, then the following
line should be printed to stderr:
biggest: no valid filenames were specified
You may find the wc command useful, especially wc -w

#!/bin/bash
validFiles="NO"
typeset -i maxWords=0
typeset -i aFileWords=0
for aFile ; do
  if [  -f $aFile -a  -r $aFile ] ; then 
     validFiles="YES"
     aFileWords="`wc -w $aFile | cut -d' ' -f1`"
     if [ $aFileWords -gt $maxWords ] ; then
        maxWords=$aFileWords
        maxFile=$aFile
     fi
  fi
done
if [ $validFiles = "NO" ] ; then
   echo "$0: no valid filenames were specified" >/dev/stderr
   exit 1
fi
echo "File $maxFile has the largest number of words (${maxWords})"
exit 0
#could also use sort -n rather than counting yourself


HMWK:  Use arrays to write a shell program called revarg that will
         print out its command line args in reverse order.

#!/bin/bash
declare -i i=1
for onearg ; do
   A[$i]=$onearg
   i=i+1
done
typeset -i x=$#
while [[ $x -gt 0 ]] ; do
   echo ${A[$x]}
   x=x-1
done




HMWK:  A.
       Write a shell program that tells you how many windows a user
       has open. Note that each open window is assigned a unique port
       number, which you can see with the who command. e.g.,
       > who
       dwoit    pts/0   ....
       eharley  pts/3   ....
       dwoit    pts/2   ....
       This shows dwoit has 2 windows open (pts/0 and pts/2)
       The user is given as a command line argument to your program ($1).


ANSW: A.
#!/bin/bash
echo "$1 has $(who | grep "$1" | tr -s " " " " \
      | cut -d' ' -f2 | wc -l) open windows"





